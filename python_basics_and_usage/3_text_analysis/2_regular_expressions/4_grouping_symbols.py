# Также используя регулярные выражения мы можем группировать символы.
# Это нужно для того, чтобы использовать метасимвол повтора для какой-нибудь группы символов, а не
# для одиночного символа.

# Также мы можем использовать группировку для того, чтобы переиспользовать группу целиком.

# Для группировки необходимо использовать метасимвол круглых скобок, в которые мы заключаем
# группу символов, которую мы бы хотели в нашем случае повторить.
# Тогда под регулярное выражение (test)* мы можем поматчить строку test.

import re

pattern = r"(test)*"
string = "testtest"
match = re.match(pattern, string)
print(match)

# Близко к группировке символ или | и через него мы можем указать, что нам подходит или данная группа
# символов или другая.

print('***')
pattern = r"(test|test)*"
string = "testtext"
match = re.match(pattern, string)
print(match)

# Метасимвол | или обладает наименьшим приоритетом в регулярных выражениях.
# Это значит, что если мы не используем группы внутри длинного регулярного выражения и вставляем символ или,
# мы поделим наше регулярное выражение на две части и будем находить либо первую часть, либо вторую.

# Таким образом, если вне группы написать abc

print('+++')
pattern = r"abc|(test|text)*"
# string = "testtext"  # <re.Match object; span=(0, 8), match='testtext'>
string = "abc"  # <re.Match object; span=(0, 4), match='test'>
match = re.match(pattern, string)  # <re.Match object; span=(0, 3), match='abc'>
print(match)

# Однако самое замечательное в группах то, что мы запоминаем какие символы попали в конкретную группу.
# Поставим пару скобок и обернем всю строку abc и весь результат, который мы поймали данным регулярным
# выражением обернем в одну группу.

print('@@@')
pattern = r"((abc)|(test|text)*)"
# string = "testtext"  # <re.Match object; span=(0, 8), match='testtext'>
string = "abc"
match = re.match(pattern, string)  # <re.Match object; span=(0, 3), match='abc'>
print(match)
# Затем у нашего матча можем вывести значение метода groups()
print(match.groups())  # ('abc', 'abc', None)

# Мы вывели в консоль значение 3-х групп.
# И каждой группе, которую мы нашли, будет соответствовать пара открывающей и закрывающей скобки.
# Группы, которые мы вывели перечисленны в том порядке, в котором записаны открывающие их скобки в
# регулярном выражении.

# 1-я группа соответствует всему регулярному выражению, потому что под первую открывающую
# скобку подпало все регулярное выражение. (abc)|(test|text)*

# Второй группе будет соответствовать (abc) маленькое выражение.

# В третьей группе будет содержать (test|text), в которую сейчас ничего не попало.

# Когда используем метасимвол повторения * то войдет в группу последнее вхождение

# Определим следующее регулярное выражение.

print('$$$')
pattern = r"Hello (abc)|(test)"
string = "Hello abc"
match = re.match(pattern, string)
print(match)
print(match.group(0))  # Все регулярное выражение.
print(match.group())  # Аргумент по умолчанию равен нулю.
print(match.group(1))  # Содержимое первой группы.

# Однако самое замечательное в группах то, что мы можем использовать уже найденную группу
# прямо внутри регулярного выражения.

print('???')
pattern = r"(\w+)-\1"  # Найди такую группу, которую ты уже нашел
string = "test-test"  # <re.Match object; span=(0, 9), match='test-test'>
# string = "test-text"  # None - вторая группа не совпала с первой.
match = re.match(pattern, string)
print(match)

# Номер, который следует после обратного слеша соответствует номеру группы.
# Т.е. если мы пишем \1, то мы имеем в виду первую группу или группу, которая соответствует первой
# открывающей скобке.
# А если мы напишем \3, то мы имеем в виду 3-ю группу, или группу, которая соответствует 3-й открывающей
# скобке.

# Также одним из самых мощных механизмов является, то что мы можем переиспользовать группу внутри функции
# sub().
# При этом указывать сырые строки, которые мы указываем на замену.
# И тогда останется по первому слову из пары совпадающий слов.

print('^^^')
pattern = r"(\w+)-\1"
string = "test-test chow-chow"
duplicates = re.sub(pattern, r"\1", string)
print(duplicates)

# Аккуратнее нужно быть с функцией findall().
# Если до того, как мы начали использовать группы в функциях findall() возвращал нам целиком
# ту подстроку, которая подходила под шаблон, теперь она будет возвращать нам кортеж групп.

# Если в нашем коде заменить функцию sub() на findall() и убрали замену.

print('>>>')
pattern = r"((\w+)-\2)"  # 1 меняем на 2, потому что данное открывающая скобка теперь стала второй.
string = "test-test chow-chow"
duplicates = re.findall(pattern, string)
print(duplicates)  # ['test', 'chow']

# После добавления () в регулярку.
# [('test-test', 'test'), ('chow-chow', 'chow')]

# То нам бы вернулся список.
# Добавим отлов всего регулярного выражения целиком.

# Мы поймали кортежи по две группы.
# 1-й группой является все наше регулярное выражение.
# А 2-й группой является первое слово, которое через - является удвоенным.

# Таким образом, группировка является очень мощным инструментом.
# Во-первых, мы можем повторять какие-то группы символов.
# Во-вторых, мы можем переиспользовать уже найденные группы прямо внутри нашего регулярного выражения.
