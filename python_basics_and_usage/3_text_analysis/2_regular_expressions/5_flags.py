# Внутрь каждой функции можем передать флаг, чтобы указать как вести себя с данным регулярным выражением.
# Например, мы можем сказать, что нас не очень интересует, являются ли буквы заглавными или строчными.

# Для того чтобы это сделать мы можем использовать флаг IGNORECASE, который находится внутри модуля.
import re

x = re.match(r'text', 'TEXT', re.IGNORECASE)
print(x)

# Можем убедиться, что наше регулярное выражение, которое содержит в себе строчные буквы текст,
# нашло и заглавные буквы ТЕКСТ в строке.

# Давайте попробуем вывести дополнительную информацию о нашем регулярном выражении.
# Для этого используем флаг DEBUG.
# Для начала немного изменим нае выражение.

x = re.match(r'(te)*xt', 'TEXT',
             re.IGNORECASE | re.DEBUG)  # Чтобы добавить один флаг к другому используем битовое или |
print(x)

# Мы увидим, что наша отдельно выделенная группа отделилась в subpattern - SUBPATTERN 1 0 0
# Также увидим, т.к. мы применили * т.к. мы ищем "жадно" от 0 до очень большого числа. - MAX_REPEAT 0 MAXREPEAT
# И также каждому буквенному символу в нашем регулярном выражении соответствует его код
# в таблице юникода.

# А если мы поставим ? после *
print('\n\n')
x = re.match(r'(te)*?xt', 'TEXT', re.IGNORECASE | re.DEBUG)
print(x)

# Теперь мы ищем не жадно, а минимальное вхождение, которое бы удовлетворило наше регулярное выражение.
# MIN_REPEAT 0 MAXREPEAT

# В течении данного урока мы рассмотрели лишь часть метасимволов, часть функций, которые есть в нашем модуле.
# Даже часть флагов, которая там определена.
# Для полного списка нужно проследовать к документации, однако даже этих знаний будет хватать для того,
# чтобы превратить регулярные выражения в мощнейший инструмент, который позволит искать информацию
# внутри любого текста.
