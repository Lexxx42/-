# Теперь, когда мы убедились в том, что код исполняется, когда мы его импортируем,
# давайте поговорим о том, какие проблемы при этом могут возникнуть.

# Первая проблема, которая приходит в голову, -- наш код-модуль может содержать в себе не только
# определение классов и функций, которые мы бы хотели импортировать.
# А так же вычисление каких-нибудь значений, которые могут считаться долго и в общем-то
# не нужны, когда мы их импортируем.

# Создадим файл fib.py.
# Внутри него мы определим рекурсивную функцию для вычисления чисел фибоначи.
# А затем выведем значение нашей функции от числа 31.
# Если мы запустим этот скрипт, то мы убедимся в том, что вычисление значения
# функции фибоначи от числа 31 занимает некоторое время.

# Таким образом, когда мы попробуем импортировать наш модуль fib из нашего файла
# import fib
# Сперва будет вычисляться принт(фиб(31)) потом уже наша программа.

# Нам очень хочется разграничивать тот код, который мы будем исполнять при импорте,
# от того кода, который нам исполнять при импорте не стоило.
# Для этого внутри модуля нам всегда доступна глобальное имя __name__

# Для того чтобы к этому имени обратиться, в начале нашего файла fib.py распечатаем его на экран.
# Когда мы выведем его на экран мы увидим текущее имя модуля.
# Т.е. когда мы запускаем наш модуль fib.py с помощью интерпретатора,
# то наш модуль носит имя __main__, а если мы наше имя попробуем импортировать.

import fib

# То имя модуля внутри модуля fib изменится на само имя модуля.

# Таким образом, для того чтобы понять, когда нас импортируют, а когда нас запускают в интерпретаторе,
# необходимо просто сравнить текущее имя с именем __main__

# Тогда давайте это проделаем.
# Мы бы хотели в том случае, когда у нас вызывают в качестве скрипта выводить текущее имя модуля и значение
# 31го числа фибоначи.
# А если нас импортируют, мы просто хотели бы импортировать функцию fib()
print(fib.fib(9))
# Таким образом, если вы пишете программу на языке python, в которой есть интересные и полезные детали,
# которые хотелось затем переиспользовать и импортировать, вы можете составить свою
# программу так, чтобы эти интересные детали оказались выше нашего условного оператора,
# где мы сравниваем имя нашего модуля с мейном.
# А тот код, который оказался внутри этого условного оператора, при импорте исполняться не будет.

# Таким образом в нашем примере при импортировании исполнится только тот, который находится
# выше условного оператора if. Потому что когда мы импортируем, имя текущего модуля будет равно
# имени нашего модуля, т.е. строке fib, а в тот момент, когда мы его исполняем в качестве скрипта
# он действительно зайдет внутрь, потому что имя модуля будет равно __main__
