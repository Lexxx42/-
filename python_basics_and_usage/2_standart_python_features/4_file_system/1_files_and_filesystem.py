# Тема данного урока - файлы и работа с файловой системой.

# Прежде чем мы начнем, стоит напомнить, что мы рассматриваем 2 типа файлов:

# 1-й тип файлов мы называем текстовыми.
# Мы считаем, что содержимое данных файлов - текст или может быть интерпретировано в качестве текста.

# В противовес им мы имеем бинарные или двоичные файлы, содержимое которых мы не можем интерпретировать
# в качестве текста.

# Примером текстового файла может послужить исходный код ваших программ, формат txt и html страницы.

# К бинарным файлам можно отнести почти все остальное, что мы за текст не считаем: mp3, gif, картинки и т.д.

# В рамках данного урока я не буду долго рассказывать по работе с бинарными данными.
# Считаю, что для любого популярного формата бинарных данных уже точно существуют библиотеки
# языка python которые умеют с форматами данных файлов работать.

# Например, если вы хотите работать с изображениями, то вы можете использовать библиотеку Pillow,
# если вы хотите работать с музыкальными данными, то вы можете начать со встроенной библиотеки
# wave, а закончить например Python Audio Tools.

# С текстовыми файлами приходится работать постоянно и поэтому им в течении нашего курса будет уделено
# больше внимания.

# Давайте в вами разберемся и научимся открывать файлы и что-нибудь с них считывать.

# f = open("test.txt", "r")

# Таким образом, функция open() аргументами принимает имя файла, который мы хотим открыть и режим,
# в котором мы хотим его открыть.

# Мы можем открыть файл для чтения, для записи, для записи в конец, и даже если сильно хочется, то мы можем
# его открыть в бинарном формате.

# Таким образом, режим определяет намерение с которым мы открываем данный файл.
# Если мы хотим из файла считать, то мы откроем его для чтения. А если хотим
# в него что-то записать, то откроем его для записи.

# r (read) - открыть для чтения (по умолчанию)
# w (write) - открыть для записи, содержимое стирается
# a (append) - открыть для записи, запись ведется в конец
# b (binary) - открыть в бинарном режиме
# t (text) - открыть в текстовом режиме (по умолчанию)
# r+ - открыть для чтения и записи
# w+ - открыть для чтения и записи, содержимое стирается

# Что важно, мы можем сочетать эти режимы.
# f = open("test.txt", "rb")

# Это далеко не все режимы, в которых мы можем открыть файл, но чаще всего хватает 3-х:
# r, w, a

# Функция open() возвращает нам file object, благодаря которому мы можем читать данные,
# записывать данные. Но что самое главное - file object нужно закрывать, когда вы с файлом поработали.
# Потому тчо надо освобождать системные ресурсы, которые были затрачены на то, чтобы
# поддерживать соединение с файлом.

print("1")
f = open("test.txt")
# x = f.read(5)  # Передаем число символов, которые хотим считать из файла.
# print(x)  # First
# y = f.read()  # Если не передадим аргумент, то считаем наш файл до конца
# Можно вывести представление файла в качестве строки.

z = f.read()
z = z.splitlines()  # ['First line', 'Second line', 'Third line']
print(repr(z))  # 'First line\nSecond line\nThird line'
f.close()

# Представление информации в качестве строк - достаточно старое и базовое.
# Мы бы не хотели страдать от того, что в одной ОС для переноса строки используются
# \n а в другой - другая последовательность символов.

# Для того чтобы мы могли разделить любой текст по строкам в не зависимости от ОС
# в языке python есть метод splitlines()
# ['First line', 'Second line', 'Third line']

# Мы увидим, что нам успешно удалось разбить файл на 3 строки и при этом они не
# содержат символов переноса строки.

# Однако может случиться так, что наш текстовый файл занимает достаточно много места на нашем диске.
# При этом если мы будем только использовать метод 'r' мы будем занимать достаточно много места
# в оперативной памяти, когда мы его читаем.
# Потому имеет смысл считывать наш файл построчно.

print("2")
f = open("test.txt")
z = f.readline().rstrip()
print(z)
f.close()
# Однако более каноничным перебором строк внутри файлов является конечно же итерация по file object-у.
# Дело в том, что в file object-а есть итератор. И итератор каждый раз, когда мы будем
# вызывать следующий элемент, будет возвращать строку из файла.

# Этот итератор написан эффективно по памяти, т.е. он никогда не выгружает файл в память целиком
# и считывает файл лишь до того момента, пока не встретит следующий перенос строки.

# Давайте перепишем считывание нашего файла.

print("3")
f = open("test.txt")
for line in f:
    print(line.rstrip())
x = f.read()
print(repr(x))
f.close()

# Важно понимать, что когда в файле не осталось не считанной информации, то метод read()
# будет возвращать нам пустую строку.

# Таким образом, считывание из файлов в языке python устроено достаточно просто.

# Если вы знаете сколько символов вы хотите считать вы можете использовать метод read()
# и передать в него аргумента количества символов для считывания.

# Если вы хотите считать файл целиком, то можете просто использовать метод read() и не
# передавать в него никакие аргументы.

# А если файл достаточно большой и вы хотите считать его построчно, то можете цикл
# for и file object.
