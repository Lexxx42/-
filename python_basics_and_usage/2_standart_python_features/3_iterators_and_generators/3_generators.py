# Однако, чтобы написать итератор в языке python приходится использовать классы,
# это достаточно сложно,
# потому что даже такой простой итератор, который бы перебирал k случайных значений из
# диапазона 0,1 занял целых 14 строк.

# Это достаточно много для такой простой задачи.

# Можем ли это сделать как-то проще?

# Да на самом деле можем. Потому что в языке python существуют генераторы.

# Генераторы - это по сути функции, в который вместо слова return мы используем слово yield.
# И при этом вместо того, чтобы значения возвращать, оно будет генерировать нам следующее значение.


from random import random


class RandomIterator:
    def __iter__(self):
        return self

    def __init__(self, k):
        self.k = k
        self.i = 0

    def __next__(self):
        if self.i < self.k:
            self.i += 2
            return random()
        else:
            raise StopIteration


# Давайте попробуем переписать наш RandomIterator используя генератор.
def random_generator(k):
    for _ in range(k):
        yield random()


# Прежде всего генератор - это функция. В нашем случае, мы называем функцию random_generator().
# Она принимает аргумент k. Этот аргумент определяет сколько случайных чисел из диапазона 0-1
# мы бы хотели вывести.

# Затем внутри цикла for, что мы бы хотели k раз вернуть случайное значение из диапазона 0-1.

# Таким образом, отличие генератора от обычной функции заключается в том, что с помощью
# ключевого слова yield, которое мы используем вместо ключевого слова return, мы можем
# вернуть значение из функции сразу несколько раз.
# А спрашивать какое именно значение будет следующим мы будем с помощью функции next().

# Также важно понимать, что интерпретатор смотрит на все тело функции сразу.
# И если он хотя бы раз встречает слово yield, то он понимает, что эта функция является генератором.

# А вызов генератора ведет себя не так же, как вызов функции.

# Давайте создадим переменную gen, в которую мы сохраним результат вызова
# функции random_generator()

gen = random_generator(3)
print(type(gen))


# Когда мы вызываем функцию с ключевым словом yield внутри, нам возвращается объект генератор.
# Этот объект генератор примечателен тем, что он знает целиком все тело нашей функции.
# И исполнение тела функции начнется лишь тогда, когда мы попросим у генератора следующий элемент.

# Когда мы его попросим, он начнет с самого его начала исполнять нашу функцию до первого ключевого
# слова yield. Тогда когда он встретит слово yield он вернет значение наружу.
# Туда где мы вызвали функцию next().
# Но что самое главное, когда мы возвращаем значение мы также запоминаем
# и все состояние нашей функции.
# Чтобы затем, когда мы вызвали next() в следующий раз, мы продолжили исполнение не с начала
# функции, а с того места, где мы до этого остановились.
# Затем, если в какой-то момент мы не найдем ключевое слово yield, мы бросим ошибку StopIteration.

# Рассмотрим на простом примере.

def simple_gen():
    print("Check point 1")
    yield 1
    print("Check point 2")
    yield 2
    print("Check point 3")


gen = simple_gen()
print("+++")
x = next(gen)
print(x)
y = next(gen)
print(y)
# z = next(gen)

# Таким образом, с помощью генераторов в языке python реализуется концепция отложенного исполнения.
# Мы продолжим исполнение функции лишь тогда,
# когда нам в действительности понадобится следующее значение.
# Давайте вернемся к нашему примеру к random_generator.

print("random_generator")
gen = random_generator(3)
for i in gen:
    print(i)


# Таким образом, генераторы - это удобный синтаксис для написания итераторов.
# Вместо того чтобы писать класс, внутри которого обязательно нужно реализовать два метода
# __iter__() и __next__() мы написали одну функцию, которая принимала всего лишь 1 аргумент.
# И вместо return использовала ключевое слово yield.
# Тем самым давая понять, что она будет производить сразу несколько значений, которые
# нужно вернуть из функции.

# А теперь вопрос для самых любопытных: если мы заменили ключевое слово return
# на ключевое слово yield, что же произойдет, если мы используем ключевое слово return
# внутри генератора?

# Важно понимать, что генератор заканчивает исполнение тела функции ровно тогда же,
# когда и обычная функция заканчивает исполнение своего тела.
# Т.е. если мы дошли до конца тела функции, генератор понимает, что он больше не сможет встретить
# конструкцию yield и он бросает ошибку StopIteration.

# Однако если генератор внутри тела функции встретит конструкцию return, то он также поймет,
# что ему нужно прекратить свое исполнение и бросить ошибку StopIteration.

# Давайте внутрь нашего генератора вставим конструкцию return.

def simple_gen():
    print("Check point 1")
    yield 1
    print("Check point 2")
    return "Teleport bread!"
    yield 2
    print("Check point 3")


gen = simple_gen()
print("+++")
x = next(gen)
print(x)
y = next(gen)
print(y)
# z = next(gen)

# Однако, если мы будем использовать не пустую конструкцию return, а что-нибудь туда передадим,
# то тогда мы увидим очень интересное поведение return, когда оно используется внутри генератора.

# То что мы передали внутри конструкции return будет сообщением внутри ошибки StopIteration.

# Таким образом, генераторы в языке python - это такой удобный синтаксис для написания итераторов,
# он ведет себя почти так же как функция, но при этом с помощью конструкции yield мы
# можем возвращать сразу несколько значений из функции.

# Важно помнить, что исполнение тела функции происходит лишь тогда, когда мы вызываем next()
# и происходит он от одного yield-а до следующего, а если следующий yield он не нашел,
# то тогда он заканчивает свое исполнение и бросает ошибку StopIteration.
