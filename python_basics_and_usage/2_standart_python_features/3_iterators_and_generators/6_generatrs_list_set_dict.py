# Кроме списков и генераторов, такой же синтаксис в Python 3 возможен для сетов и словарей!
# {ord(x) for x in 'spaam'}    # генерируем set {112, 115, 109, 97}
#
# {x:ord(x) for x in 'spaam'}  # генерируем dictionary {'s': 115, 'm': 109, 'p': 112, 'a': 97}


# Если список содержит последовательно пары key value, то так можно преобразовать в словарь:

# d = ['Dota', 'sucks', 'Python', 'rules', 'Saperavi', 'depends']
# dictus = {d[x]: d[x+1] for x in range(0, len(d), 2)}

# Очень часто возникает необходимость создавать какие-то списки.
# Часто мы создаем пустой список, затем добавляем туда элементы с помощью метода append().

# Для всего этого в языке python есть куда более лаконичный синтаксис в английском языке
# называется list comprehension, в русском проще всего его называть генерацией списков.

# Пускай есть список
x = [-2, -1, 0, 1, 2]
# Мы бы хотели создать список у, который содержал бы квадраты этих значений

y = []
for i in x:
    y.append(i * i)
print(y)

# Однако в языке python есть специальный синтаксис, позволяющий сделать это сильно проще.
# Мы можем объявить содержимое списка прямо внутри списка использую list comprehension.

z = [k * k for k in x]
print(z)

# Так же внутри такой конструкции мы можем использовать условный оператор if.
# Мы можем добавить данный элемент внутрь листа только в том случае, если i > 0.

z = [k * k for k in x if k > 0]
print(z)

# Остались квадраты только тех чисел, которые в списке х были > нуля.

# Давайте попробуем разобраться как же в общем случае может выглядеть такая генерация списка.
# Сначала у нас идет что мы должны поместить в наш список, -- это такое выражение, в нашем случае
# это выб квадрат числа k.
# Затем идет цикл for - мы перебираем элементы из какого-то множества или из какого-нибудь итератора.
# Затем у нас может несколько раз последовательно идти цикл for.
# В конце у нас может следовать условный оператор.
# Если он верен, мы действительно помещаем элемент.
# А если значение логического оператора False, то мы не помещаем элемент в наш список.

# Давайте создадим конструкцию посложнее.
print("_+_")
z = [(x, y) for x in range(3) for y in range(3) if y >= x]
print(z)

# Поместим в наш список z такие пары x y, что x в интервале [0,3), y in [0, 3) и y >= x.

# Эквивалентно

z = []
for x in range(3):
    for y in range(3):
        if y >= x:
            z.append((x, y))
print(z)
# Несмотря на то, что такие две конструкции абсолютно эквивалентны, первая конструкция сильно короче
# и при этом она не теряет в своей понятности.
# Мы понимаем, что нужно перебрать х и у и если у больше или равен х, то мы добавим в список значение
# пары (х, у).

# Однако, если мы данную конструкцию поместим в круглые скобки вместо квадратных, то мы получим
# нечто не менее интересное.
# Мы получим генератор, который будет перебирать подбирать под условие объекты.

print("№;%:?")
z = ((x, y) for x in range(3) for y in range(3) if y >= x)
print(z)
print(next(z))
print(next(z))

# Таким образом, если вы составляете список используя цикл for и условный оператор, то
# вам лучше использовать данный синтаксис, это сделает вашу запись короче и при этом
# ваш код не перестанет быть понятным
