# Еще одна библиотека, где мы можем найти какие-то полезные вещи для применения в функциях
# является functools.

# И мы рассмотрим пожалуй главную функцию из нее, которая и делает ее такой замечательной,
# это функция partial.

# Функция partial позволяет запомнить некоторые аргументы, с которыми мы бы хотели вызвать функцию.
# И возвращает нам функцию, в которую нам эти аргументы больше не нужно передавать.

# Давайте рассмотрим самый простой пример:
# Если вы передаете в конструктор нашего целочисленного типа int строку,
# то можете укатать систему счисления, в которой находится данная строка.

# Допустим мы бы хотели написать функцию, которая бы по умолчанию считала,
# что все числа, которые мы передаем в строке являются двоичными.

from functools import partial

x = int("1101", base=2)
print(x)

# Однако мы хотим написать функцию, которая бы принимала аргументом лишь одно число.
# А делала бы она то же самое: вызывала бы функцию int() и указывала бы явным
# аргументом base = 2.

# Для этого нам нужна функция partial из библиотеки functools.
# Мы можем указать, что нам нужна функция с уже частично примененными аргументами.

int_2 = partial(int, base=2)
x = int_2("1101")
print(x)

# Таким образом мы можем сказать, что функция partial берет функцию и частично подставляет
# в нее какие-то из аргументов.
# При этом возвращает нам новую функцию, в которую больше эти аргументы подставлять уже не нужно.

# Теперь применяя все полученные знания мы можем написать одну простую универсальную
# функцию. Пускай внутри нашего списка находятся, например,
# последовательности (кортежи, строки, списки).

# Мы можем отсортировать наш большой список по последнему элементу допустим в кортеже или строке.

# Для этого возьмем функцию sort()

import operator as op

x = [
    ("Guido", "van", "Rossum"),
    ("Heskel", "Hurry"),
    ("John", "Kelss")
]

sort_by_last = partial(list.sort, key=op.itemgetter(-1))
# 1-м аргументом принимается self
# 2-м аргументом key, выбираем последний элемент

print(x)
sort_by_last(x)
print(x)

# Наша функция является универсальной

y = ["abc", "cba", "abb"]
sort_by_last(y)
print(y)

# В данном уроке мы с вами рассмотрели некоторые подходы и библиотеки,
# которые мы можем использовать в так называемом функциональном подходе.

# Мы с вами считали, что почти все является функцией.
# Даже конструкторы типов. Потому что мы можем их вызвать и передать туда аргументы
# и получить какое-то значение обратно.

# Как мы смогли заметить некоторые вещи мы можем написать с помощью функционального подхода
# достаточно элегантно.
# Однако они требуют дополнительного понимания того, что передаем в функцию внутри функций
# и некоторые функции даже возвращают функции.
