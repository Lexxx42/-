# В связи с тем, что мы передаем функции внутрь функций, возникает желание писать еще более
# короткие функции. Для этого в языке python есть лямбда функции.

# x = input().split()
# xs = (int(i) for i in x)
#
# even = lambda x: x % 2 == 0
#
# evens = list(filter(even, xs))
# print(evens)

# Лямбда-функции - это всего лишь синтаксис создания новых функций.
# Синтаксис достаточно простой:
# 1. Сначала идет ключевое слово lambda.
# 2. До двоеточия мы указываем аргументы, какие принимает наша функция.
# И здесь стоит отметить, что верны все те же правила, которые верны для аргументов
# обычной функции. Т.е. мы можем определить аргументы, которые со *, с двумя **,
# можем определить аргументы со значением по умолчанию.
# 3. После двоеточия идет одно выражение, -- это то выражение, которое должно быть
# возвращаемым значением нашей функции.

# Получается, в нашем коде мы сначала создали объект функцию, используя синтаксис
# лямбды. А затем присвоили имени even ссылку на данную функцию в оперативной памяти.

# Но самое замечательное в синтаксисе лямбд заключается в том, что мы можем подставить их
# внутрь функции.

# Мы можем обратить внимание, что в нашем коде мы нигде не вызываем функцию even.
# Мы лишь передаем ее одним аргументом, поэтому мы можем избавиться от имени even
# и передать лямбду целиком вместо аргумента.

# x = input().split()
# xs = (int(i) for i in x)
#
# evens = list(filter(lambda x: x % 2 == 0, xs))
# print(evens)

# Синтаксис лямбд функции изначально задумывался очень простым.
# С начало писалось ключевое слово lambda.
# Затем мы описываем аргументы, которые принимает функция.
# А затем мы в одно выражение пытаемся описать возвращаемое ей значение.

# Поэтому, если вы пишете функцию, которые изначально что-то вычисляют и
# лишь затем возвращают значения, то вам все таки лучше писать обычные функции.

# Прежде всего, вам будет сложно написать большую функцию внутри одной лямбды,
# потому что вам нужно использовать лишь одно выражение.
# Во-вторых, длинные лямбда функции очень сложно читать.

# Когда же мы еще передаем функции внутрь другой функции?

# Прежде всего вспоминается сортировка.
# Когда мы вызываем метод sort() у списка, то мы можем передать именованный аргумент key.
# Мы можем передать туда функцию, которая будет сначала высчитана от всех элементов нашего списка.
# Затем наш список будет отсортирован не по порядку элементов, а по порядку значений данной функции.

# Пускай у нас есть заданный список имен.

x = [
    ("Guido", "van", "Rossum"),
    ("Heskel", "Hurry"),
    ("John", "Kelss")
]


def length(name):
    return len(" ".join(name))


name_lengths = [length(name) for name in x]
print(name_lengths)

x.sort(key=length)
print(x)

# Таким образом, передав дополнительную функцию в качестве аргумента key,
# мы сначала вычислили значение данной функции на каждом элементе нашего списка,
# а затем отсортировали наш список именно по этим значениям.

# Однако, если бы я не хотел использовать функцию length() дважды,
# то вероятнее всего я бы просто написал одну лямбда функцию, которую я бы
# и передал в метод sort()

x.sort(key=lambda x: len(" ".join(x)))
print(x)
