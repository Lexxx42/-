# Большое внимание в языке python уделено работе с последовательностями
# будь то списки или итераторы и работе с функциями.

# Дело в том, что большая часть стандартных библиотек языка python принимает
# одно и второе в качестве аргументов.

# Далеко за примерами ходить не нужно, давайте рассмотрим map(),
# который мы использовали для того, чтобы считывать целые числа из терминала.

# x = input().split()
# print(x)
# map_obj = map(int, x)  # map является итератором
# print(map_obj)
#
# n = next(map_obj)
# k = next(map_obj)
# print(n, k)

# Однако в языке python есть механизм распаковки, что позволяет нам использовать
# множественное присваивание.

# Если слева от знака присваивания находится больше чем одна переменная,
# а справа находится что-нибудь по чему можно проитерироваться (список, кортеж, итератор),
# то интерпретатор пытается распихать элементы данной последовательности по нашим переменным.
# Если элементов там оказалось больше чем нужно, то тогда он упадет с ошибкой,
# а если меньше чем нужно, то тоже упадет с ошибкой.

# запись
# n,k = map(int, x)
# Работала из-за механизма распаковки.
# Она перестала бы работать, если было бы больше чисел в строке ввода или меньше.

# Важно понимать, что объекты класса map вычисляют значения достаточно лениво.

# В тот момент, когда мы создаем объект map(f, x) нашего класса,
# то мы, на самом деле, запоминаем лишь 2 ссылки.
# Мы запоминаем одну ссылку на функцию, и запоминаем одну ссылку на итератор 2-го аргумента.

# В тот момент когда нас спрашивают, какой же элемент является следующим: next() - ?
# Лишь в этот момент мы считаем следующий элемент из нашего итератора - next(it)
# и затем применяем к нему ту функцию, которую нам передали: f(next(it)).

# Вы можете заметить, что мы можем написать то же самое используя обычный генератор.

# print("_+_")
# n, k = (int(i) for i in x)
# print(n, k)

# Вы можете сами решать какой синтаксис вам удобнее использовать, однако стоит перестать бояться
# передавать функцию внутрь других функций.

# Давайте рассмотрим класс filter.

# filter принимает в конструктор 2 аргумента: функция и последовательность элементов,
# которую мы хотим отфильтровать.

# Наша функция должна возвращать логическое значение True в том случае, если элемент
# последовательности нам подходит и False, если не подходит.

# Давайте попробуем считать список и оставить только те, которые являются четными.

# x = input().split()
# xs = (int(i) for i in x)
#
#
# def even(x):
#     return x % 2 == 0
#
#
# evens = filter(even, xs)
# for i in evens:
#     print(i)

# Конструктор класса filter возвращает нам filter_object.
# Этот filter object в свою очередь является итератором, внутри него реализован
# метод next().

# Однако, конструктор класса, которым вы вероятнее всего захотите воспользоваться,
# когда будете пользоваться итераторами, -- это конструктор класса list.

# Дело в том, что если в конструктор класса list мы поместим итератор,
# то он попробует собрать все элементы из данного итератора и поместить их
# внутрь одного листа.

# Однако пользоваться этим стоит аккуратно.
# Почти так же как с файлами, если вы уверены, что ваш итератор, во-первых,
# возвращает конечное число элементов и второе, если они разумно умещаются в оперативной памяти.

x = input().split()
xs = (int(i) for i in x)


def even(x):
    return x % 2 == 0


evens = list(filter(even, xs))
print(evens)
