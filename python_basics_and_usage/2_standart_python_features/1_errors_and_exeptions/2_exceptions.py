# Однако не все ошибки, которые возникают в процессе исполнения нашего кода достаточно фатальны,
# чтобы интерпретатор перестал исполнять код вообще.

# Некоторую часть ошибок мы можем поймать и затем обработать.
# Давайте посмотрим, как мы можем это делать.

# x = [1, 2, "hello", 7]
# x.sort()
# print(x)

# print("I can catch")

# Мы бы захотели запустить код так, что если внутри него возникло исключение
# то пусть выведется на экран. А затем продолжить исполнение кода дальше и вывести принт()

# Для этого в языке python есть try

try:
    x = [1, 2, "hello", 7]
    x.sort()
    print(x)
# В теле try мы указываем тот код, который хотели бы проверить.
# затем указываем except и тип того исключения, которое может возникнуть в процессе исполнения тела try
except TypeError:
    print("Type error :(")
print("I can catch")
print("***")

# После запуска убедимся, что после возникновения ошибки наш код продолжил работу и что действительно возник
# TypeError, когда использовался метод сорт().
# Он дошел до блока except и увидел, что мы ловим TypeError, мы выводим его значение и после этого
# успешно продолжаем исполнение.


# Возникновение в том месте программы является не критичным, чтобы целиком останавливать исполнение
# всей программы.
# Конструкция try-except позволяет нам выбрать типы ошибок, которые мы не считаем критичными, как-то их обработать
# и затем продолжить исполнение кода.

# Попробуем узнать больше от try-except блоках


# def f(a, b):
#     try:
#         return a / b
#     except TypeError:
#         print("Type error")
#
#
# f(5, [])
# Если попытаемся выполнить код, который не попадает внутрь try-except блока
# Например деление на ноль. То не обработанная ошибка приведет к прекращению исполнения кода.

# f(5, 0)
# Что же сделать, чтобы обработать деление на ноль?

# Мы можем написать еще один except блок

# def f(a, b):
#     try:
#         return a / b
#     except TypeError:
#         print("Type error")
#     except ZeroDivisionError:
#         print("Zero division :(")
#
#
# f(5, 0)

# Когда мы пишем сразу несколько except блоков нужно помнить, что любое исключение
# будет обработано лишь одним из них, первым под который она подойдет.
# Остальные except блоки не будут исполняться.

# Однако мы бы могли поймать ошибку деления на ноль еще по другому.

# Важно помнить, что мы можем ловить наши исключения в любой момент исполнения на стеке.

# Мы бы могли поймать это исключение внутри функции или во время вызова функции.
# def f(a, b):
#     try:
#         return a / b
#     except TypeError:
#         print("Type error")
#
#
# try:
#     f(5, 0)
# except ZeroDivisionError:
#     print("Zero division :(")

# Однако мы можем поймать одним except блоком сразу несколько исключений.
# Для этого в except блок надо передавать кортеж, содержащий типы этих исключений.

# Вернемся к первому варианту, когда мы написали отлов ошибок в функции.

# def f(a, b):
#     try:
#         return a / b
#     except (TypeError, ZeroDivisionError):
#         print("Error :(")
#
#
# f(5, 0)

# Так же в языке python мы можем поймать сам объект ошибки.
# Для этого нам нужно указать после типа, который мы ловим as и имя того объекта, который мы бы хотели поймать.

# def f(a, b):
#     try:
#         return a / b
#     except (TypeError, ZeroDivisionError) as e:
#         print(type(e))
#         print(e)
#         print(e.args)  # У каждой ошибки есть атрибут args
#
#
# f(5, "ы")

# Может случиться такое, что мы не знаем какой конкретно тип ошибки может произойти в том коде,
# который мы хотим исполнить. И поэтому мы чаще всего считаем, что там не должно происходить каких-либо ошибок.
# В таком случае мы иногда захотим исполнить try-except блок без указания конкретных типов исключений,
# которые надо ловить.


# def f(a, b):
#     try:
#         return a / b
#     except:
#         print("Error :(")
#
#
# f(5, 0)

# Стоит понять какими же механизмами мы пользуемся, когда пытаемся понять, подходит ли исключение, которое
# возникло внутри кода в данный конкретно except блок.

# Давайте для понимания еще сильнее упростим код:

try:
    15 / 0
    # В блоке try генерируется объект исключения деления на 0. У этого объекта нет имени, однако где-то есть
    # объект е, пускай назову его е. Его не существует ни в каком неймспейсе.
    # Что же происходит, когда мы делаем except? except на самом деле проверяет, если мы на самом деле передали
    # 1 класс, он проверяет isinstance(е, ZeroDivisionError) ли e в нашем случае ZeroDivisionError?
except ZeroDivisionError:
    print("Division by zero")

# Если isinstance(е, ZeroDivisionError) == True, то внутрь except блока он заходит.
# Если мы передали больше значений внутрь (больше типов внутрь except блока), то для каждого из них проверяется
# isinstance(е, TypeError), isinstance(е, ZeroDivisionError), если Тру хотя бы для одного и этих типов,
# то он заходит внутрь except блока.

# Закономерным вопросом является следующий: а почему мы не используем сравнение типов через type,
# а запускаем функцию isinstance()?

# Дело в том, что все ошибки в языке python представляют собой иерархию.
# И например ZeroDivisionError наследуется от класса ArithmeticError, т.е. является арифметической ошибкой.

print(ZeroDivisionError.mro())

# В языке python ошибки не используют множественное наследование.
# т.е. я могу точно гарантировать, что ZeroDivisionError наследуется только от ArithmeticError, а ArithmeticError
# наследуется только от Exception и т.д.

print("**")
try:
    15 / 0
    # isinstance(е, ArithmeticError) == True
except ArithmeticError:
    print("Arithmetic error :(")

# Конечно мы поймаем арифметическую ошибку потому что деление на ноль так же является
# арифметической ошибкой. Именно поэтому мы используем метод isinstance() для того, чтобы определить,
# попадает ли данное исключение в конкретный except блок.

# Т.к. для того, чтобы понять в какой из except блоков мы попадаем, мы пользуемся функцией isinstance()
# никогда не имеет смысла проверять наследника внутри одного except блока после предка в except блоке выше.

# Давайте посмотрим:
print("*---*")
try:
    15 / 0
    # isinstance(е, ArithmeticError) == True
except ArithmeticError:
    print("Arithmetic error :(")
except ZeroDivisionError:  # 'ArithmeticError', superclass of the exception class 'ZeroDivisionError',
    # has already been caught
    print("Zero division error :(")

# Все что нам осталось узнать о try-except блоке,- это ключевые слова else и finally

# Ключевое слово else используют тогда внутри try блока не возникло никакого исключения и мы возможно
# хотим что-то сделать в этом случае.
# А блок finally запускается в любом случае. Когда мы обработали исключение, когда исключения не было и даже
# когда есть такое исключение, которое мы обработать не смогли.

print("№:%;%?*%")


def divide(x1, y1):
    try:
        result = x1 / y1
    except ZeroDivisionError:
        print("division by zero")
    else:
        print("result is", result)
    finally:
        print("finally")


divide(2, 1)
divide(2, 0)
divide(2, [])

# Таким образом, в языке python есть достаточно гибкий набор инструментов для того, чтобы мы могли
# контролировать исполнение нашей программы. И если у нас возникает ошибка,
# у нас всегда есть возможность ее обработать.
