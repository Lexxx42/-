# Достаточно часто в процессе решения тех или иных задач возникает необходимость передать в функцию неопределенное число аргументов.
# предположим, что вы захотели написать функцию min(), которая бы принимала 2 аргумента а и б, и возвращала бы меньшее из них.

# Однако в определенный момент мы зададимся естественным вопросом: почему функция min() принимает всего 2 аргумента? Почему не 3?
# Что нам мешает находить минимум из 3-х, или из 4-х и т.д. Этим вопросом занялись и разработчики языка python.

# В языке python существует механизм, благодаря которому мы можем передать в функцию неопределенное число аргументов

def printab(a, b, *args):
    print('positional arg a', a)
    print('positional arg b', b)
    print('positional arg args:')
    for arg in args:
        print(arg)


printab(10, 20, 30, 40, 50)
# positional arg a 10
# positional arg b 20
# positional arg args:
# 30
# 40
# 50

# В контексте передачи аргументов, когда мы пишем *, а после нее кортеж или список, мы имеем ввиду "разверни нам кортеж или список"
# и поставь нам элементы этого кортежа или списка в качестве позиционных аргументов в функцию, а здесь же, когда мы описываем
# аргументы, которые функция принимает, мы имеем с точность до наоборот
# мы говорим интерпретатору "измени все позиционные аргументы, которые не нашли себе место и положи их в кортеж args"

# Важно понимать, что в args попадут все дополнительные позиционные аргументы, которые мы передали, а так же, что они находятся внутри args ровно в том
# порядке, в котором они принимаются, когда мы функцию вызываем

# Для именованных аргументов у нас есть похожий механизм
# Рассмотрим его синтаксис
print('***')


def printab(a, b, **kwargs):
    print('positional argument a', a)
    print('positional argument b', b)
    print('positional arguments:')
    for key in kwargs:
        print(key, kwargs[key])

# когда мы вызываем функцию и пишем 2 звездочки и передаем туда словарь. Мы имеем ввиду, что этот словарь нам нужно раскрыть и передать парой ключ:значение
# в качестве аргумента и значение аргумента и вызвать функцию с этими аргументами. Здесь же ** работаю с точностью до наоборот
# Мы говорим интерпретатору, что когда эту функцию вызывают, когда ты инициализируешь переменные возьми все именованные переменные, которые не участвовали в инициализации
# и помести их внутрь словаря kwargs


printab(10, 20, c=30, d=40, jimmi=123)
# positional argument a 10
# positional argument b 20
# positional arguments:
# c 30
# d 40
# jimmi 123

# в args попадут только те аргументы, которые в инициализации не участвовали


# Важно понимать синтаксическое определение функции
# def function_name( [ positional args,
#                    [ positional_args_with_default,
#                    [ *pos_args_name,
#                    [ keyword_only_args,
#                    [ **kw_args_name]]]]]):

# пример

def printab(a, b=10, *args, c=10, d, **kwags):
    print(a, b, c, d)


printab(15, d=15)  # 15 10 10 15
