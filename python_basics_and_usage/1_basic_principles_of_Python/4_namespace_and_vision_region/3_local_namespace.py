# необходимость создавать локальное пространство имен часто связано с функциями, со стеком вызовов и с так называемыми локальными переменными
# Мы бы хотели, объявляя функции, не боятся, что та переменная, которую мы используем внутри, перезапишет какое-нибудь значение вне функции

# Посмотрим пример

t_c = 18
tmp = 'ok'


def fahrenheit(t_c):
    tmp = t_c*9/5
    return tmp+32


print(fahrenheit(t_c))
print(tmp)

# Рассмотрим функцию, которая принимает градусы цельсия и возвращает градусы фаренгейта

# Как мы уже сказали, когда функция вызывается, она создает локальный неймспейс.
# В этом локальном неймспейсе мы будем хранить аргументы функции и локальные переменные, объявленные внутри функции.
# Когда функция завершает свое исполнение, она не просто снимается со стека, но и разрушает этот локальный неймспейс,
# который был создан.

# Нарисуем стек вызовов при выполнении этого кода

#            #
#            #
#            #
#            #
#            #
#            #      Затем на стек будут класться функции и неймспейсы, которые они создают
#   _module  # - функция module, которая главная исполняющая. и ей будет соответствовать глобальный неймспейс - global
##############                                                                           где-то под глобальным неймспейсом будет неймспейс builins


# Когда мы будет исполнять данный код, мы сперва выполним два присваивания


#            #              Состояние пространства имен global: имени ти_си будет соответствовать 18    't_c' -> 18
#            #                                                  имени 'tmp' -> 'ok'
#            #              Далее мы создаем функцию fahrenheit() и она тоже попадет в глобальный неймспейс 'fahrenheit' -> fahrenheit
#            #              После того, как мы определили функцию мы просим вывести на экран функцию fahrenheit от t_c
#            #              Тут интерпретатору нужно подумать о нескольких вещах: что такое принт, что такое фаренгейт и что за имя ти_си
#            #              Основное правило, которым пользуется интерпретатор - это сначала посмотри в локальном неймспейсе, потом посмотри в неймспейсе функции,
#   _module  #              которая это вызвала, и т.д. затем в неймспейсе global и в затем в неймспейсе builtins
##############              Используя наше графическое отображение стека, это происходило бы так.

#            #
#            #  <-- Если бы мы в момент исполнения были бы где-то здесь. Мы бы сначала посмотрели бы в нашем неймспейсе
#            #  <- Затем в функции, которая нас вызвала
#            #  <- затем в функции, которая вызвала функцию, которая нас вызвала
#            #  <- и т.д.
#            #
#   _module  #  <- затем в неймспейсе global
##############  <- затем в неймспейсе builtins

# Однако вернемся к нашему случаю, в момент исполнения принта()
# print(fahrenheit(t_c))
# Мы находились не так глубоко на стеке, у нас не было столько функций и мы находились всего лишь в функции module
# Это означает, что функция принт(), которая является первой мы бы сначала проверили в неймспейсе global, а затем в неймспейсе builtins
# имени принт() нет с неймспейсе global потому что мы его там не объявляли в неймспейсе global мы объявили только: t_c, tmp, fahrenheit
# 