# необходимость создавать локальное пространство имен часто связано с функциями, со стеком вызовов и с так называемыми локальными переменными
# Мы бы хотели, объявляя функции, не боятся, что та переменная, которую мы используем внутри, перезапишет какое-нибудь значение вне функции

# Посмотрим пример

t_c = 18
tmp = 'ok'


def fahrenheit(t_c):
    tmp = t_c*9/5
    return tmp+32


print(fahrenheit(t_c))
print(tmp)

# Рассмотрим функцию, которая принимает градусы цельсия и возвращает градусы фаренгейта

# Как мы уже сказали, когда функция вызывается, она создает локальный неймспейс.
# В этом локальном неймспейсе мы будем хранить аргументы функции и локальные переменные, объявленные внутри функции.
# Когда функция завершает свое исполнение, она не просто снимается со стека, но и разрушает этот локальный неймспейс,
# который был создан.

# Нарисуем стек вызовов при выполнении этого кода

#            #
#            #
#            #
#            #
#            #
#            #      Затем на стек будут класться функции и неймспейсы, которые они создают
#   _module  # - функция module, которая главная исполняющая. и ей будет соответствовать глобальный неймспейс - global
# где-то под глобальным неймспейсом будет неймспейс builins


# Когда мы будет исполнять данный код, мы сперва выполним два присваивания


#            #              Состояние пространства имен global: имени ти_си будет соответствовать 18    't_c' -> 18
#            #                                                  имени 'tmp' -> 'ok'
#            #              Далее мы создаем функцию fahrenheit() и она тоже попадет в глобальный неймспейс 'fahrenheit' -> fahrenheit
#            #              После того, как мы определили функцию мы просим вывести на экран функцию fahrenheit от t_c
#            #              Тут интерпретатору нужно подумать о нескольких вещах: что такое принт, что такое фаренгейт и что за имя ти_си
#            #              Основное правило, которым пользуется интерпретатор - это сначала посмотри в локальном неймспейсе, потом посмотри в неймспейсе функции,
#   _module  #              которая это вызвала, и т.д. затем в неймспейсе global и в затем в неймспейсе builtins
# Используя наше графическое отображение стека, это происходило бы так.

#            #
#            #  <-- Если бы мы в момент исполнения были бы где-то здесь. Мы бы сначала посмотрели бы в нашем неймспейсе
#            #  <- Затем в функции, которая нас вызвала
#            #  <- затем в функции, которая вызвала функцию, которая нас вызвала
#            #  <- и т.д.
#            #
#   _module  #  <- затем в неймспейсе global
# <- затем в неймспейсе builtins

# Однако вернемся к нашему случаю, в момент исполнения принта()
# print(fahrenheit(t_c))
# Мы находились не так глубоко на стеке, у нас не было столько функций и мы находились всего лишь в функции module
# Это означает, что функция принт(), которая является первой мы бы сначала проверили в неймспейсе global, а затем в неймспейсе builtins
# имени принт() нет с неймспейсе global потому что мы его там не объявляли в неймспейсе global мы объявили только: t_c, tmp, fahrenheit
# Однако, т.к. функция tmp() - является стандартным средством языка python, то имя принт() находится в неймспейсе builtins ему соответствует функция, которая
# выводит значение на экран.

# Хорошо, мы нашли имя принт в неймспейсе builtins, теперь нам нужно найти имя fahrenheit.
# Это совсем не сложно, потому что он находится в том же неймспейсе, где его и вызвали, т.е. в global и ей соответствует функция.

# Для того чтобы вычислить эту функцию нам нужно найти также имя t_c, имя t_c находится так же в global
# потому что здесь мы ее и объявили.

# Чтобы узнать, что же вывести на экран, мы сначала должны исполнить функцию fahrenheit с аргументом t_c.
# Поэтому функция fahrenheit кладется на стек


#            #
#            #
#            #
#            #
#            #
# fahrenheit #      Когда мы вызываем функцию fahrenheit, создается локальный неймспейс для этой функции - local: t_c - пока что тут только 1 аргумент, который мы объявили
#   _module  #      ему будет так же соответствует 18, как и в глобальном неймспейсе
##############

# Затем мы должны исполнить первую строку в функции fahrenheit
# Когда мы будем исполнять эту строку интерпретатор будет пытаться узнать, что же такое имя t_c
# И как мы говорили, он сначала посмотрит в локальном неймспейсе
# Он находит имя t_c в локальном неймспейсе, т.к. он является аргументом функции. Поэтому он будет его использовать
# Затем он должен присвоить переменной tmp вычисленное значение
# И важно понимать, т.к. tmp является локальной переменной, т.е. мы делаем присваивание внутри функции
# то имя tmp будет связано с локальным неймспейсом. Поэтому в локальном неймспейсе мы создаем имя tmp


#            #
#            #
#            #
#            #
#            #
# fahrenheit #      local: 't_c' -> 18, 'tmp' -> 32.4
#   _module  #
##############

# Теперь мы должны вернуть вычисленное значение прибавив к нему 32.
# Интерперетатор дойдет до этой строки, увидит имя tmp, попробует понять откуда нужно взять это имя
# В локальном неймспейсе есть имя tmp, которое можно использовать и вернет нам значение 64.4

# Далее функция fahrenheit снимается со стека и весь неймспейс, который был ей создан уничтожается


#            #
#            #
#            #
#            #
#            #
#            #
#   _module  #
##############

# И вот мы дошли до того места, когда мы снова должны вызвать функцию принт()

#            #
#            #
#            #
#            #
#            #
#  print()   #  функция принт создает себе локальный неймспейс: local - куда она передаст себе 1 аргумент 64.4, который нужно вывести
#   _module  #  Затем функция исполняется, снимается со стека и удаляет свой неймспейс
##############


#            #
#            #
#            #
#            #
#            #
#            #
#   _module  #
##############

# Затем интерпретатор видит очередную инструкцию принт()
# Он опять же находит принт() внутри неймспейса builtins, потому что его нет в global
# Затем смотрит, что же такое tmp. Он видит tmp в global, таким образом второй принт выведет строку "ок", которая определена в глобальном неймспейсе

# Такой механизм создания пространства имен, когда мы каждый раз вызываем функцию позволяет нам использовать одни и те жи имена в разных местах программы
# и поэтому не боятся, что мы перезапишем ту или иную переменную вызовом другой функции
