# Однако, когда мы пишем функции нам не всегда хватает лишь локальных переменных
# Иногда хочется и даже нужно изменить значение глобальной или переменной в пространстве имен вызвавшей нас функции.
# Для этого в языке Python есть конструкция global и nonlocal

# Предположим, что мы бы писали приложение для словаря.
# Оно хранило бы в себе слова и хранила бы переводы, однако время от времени мы бы проверяли слова на адекватность
# Если в какой-то момент времени мы понимаем, что мы встретили слово без гласных, что в общем достаточно странно,
# мы бы подумали, что с нашей программой что-то пошло не так.
# мы бы хотели где-то глобально это зафиксировать

# тогда мы бы объявили глобальную переменную ok_status она будет Тру, если все ок или Фалс, если в нашей программе что-то пошло не так

ok_status = True
vowels = ['a', 'u', 'i', 'e', 'o']


def check(word):
    # используем глобальную переменную. Такая конструкция означает,
    global ok_status
    for vowel in vowels:        # что нужно взять переменную из глобального неймспейса и именно его использовать
        if vowel in word:
            return True
    # Это значит, что когда мы присваиваем значение Фалс, если мы не нашли гласную в нашем слове, то мы используем имя ok_status
    ok_status = False
    # не из нашего локального неймспейса функции check(), а из глобального неймспейса
    return False


print(check('abacaba'))  # True
print(ok_status)  # True
print(check('www'))  # False
print(ok_status)  # False


# мы бы объявили список со всеми гласными в английском языке
# и мы бы написали функцию check(), которая бы принимала одно слово, проверяла бы входит какая-нибудь гласная в это слово

# Однако и локальных и глобальных переменных иногда тоже может не хватать
# Давайте посмотрим

# Если бы мы завернули весь наш код внутри функции f(), то тогда ok_status означал насколько хорошо исполняется именно наша функция f()
# Т.е. ok_status имел бы значение False, если в процессе исполнения f() случилось бы что-нибудь странное, например мы бы встретили слово,
# которое не содержит в себе гласных. (rhythms - не содержит гласных, но это ок слово! Примечание от меня).

# Однако, если бы мы скопировали этот код без изменений, использовали бы внутри функции check конструкцию global ok_status
# мы бы увидели именно такой вывод:
# True
# True
# False
# True - ok_status is not global!
print('***')


def f():
    ok_status = True
    vowels = ['a', 'u', 'i', 'e', 'o']

    def check(word):
        global ok_status
        for vowel in vowels:
            if vowel in word:
                return True
        ok_status = False
        return False

    print(check('abacaba'))  # True
    print(ok_status)  # True
    print(check('www'))  # False
    print(ok_status)  # True


f()
print(ok_status)  # False - global ok_status

# Когда мы вызываем функцию f() то создается локальный ok_status, а в глобальном неймспейсе у нас нет ok_status
# когда мы запускаем функцию check() мы говорим ему использовать ok_status из глобального неймспейса
# глобальному неймспейсу присваеваем значение False, однако это никак не изменяет значение ok_status внутри функции f()
# поэтому значения ok_status не меняются по ходу программы в локальном неймспейсе и более того, если после выполнения функции f()
# мы попробуем вывести глобальное значение переменной ok_status, то мы увидим, что оно появилось и стало равным False


# Т.е. такое поведение - это не совсем то, что мы хотели.
# Мы хотели, чтобы наша переменная ok_status внутри функции хранила то, как исполняется наша функция и есть ли в ней какие-либо проблемы
# в процессе исполнения.

# Для этого мы можем использовать ключевое слово nonlocal

print('\U0001F600')


def f():
    ok_status = True
    vowels = ['a', 'u', 'i', 'e', 'o']

    def check(word):
        nonlocal ok_status
        for vowel in vowels:
            if vowel in word:
                return True
        ok_status = False
        return False

    print(check('abacaba'))  # True
    print(ok_status)  # True
    print(check('www'))  # False
    print(ok_status)  # False


f()
print(ok_status)  # NameError: name 'ok_status' is not defined

# Когда интерпретатор встречает конструкцию nonlocal ok_status, это говорит ему, чтобы он нашел такое пространство имен, которое
# содержит ok_status при этом ближайшее к текущему пространство имен по пути к неймспейсу глобал.
# Т.е. Найти ближайшее пространство имен от пр-ва имен ф-ции check() до пра-ва имен global
# Которое обязательно содержит ok_status

# В нашем случае - это пространство имен функции f(), потому что внутри функции f() мы объявляем имя ok_status
# теперь функция check() работает правильным образом и наша переменная внутри функции f() ok_status хранит в себе False
# только в том случае, если в процессе исполнении функции f() произошло что-то странное и мы встретили слово, которое не содержит гласных.

# Важно, что в процессе поиска конструкция nonlocal ok_status мы никогда не будем смотреть ни в global ни в check, 
# а будем проверять пространства имен по пути от check до global

# Таким образом, не смотря на то, что стандартное поведение оператора присваивания внутри функции создает локальное имя внутри локального неймспейса
# вы далеко не ограничены лишь локальными переменными.
# Для того, чтобы не использовать локальные переменные вы можете использовать конструкции global и nonlocal