# Рядом с определением пространства имен находится понятие областей видимости
# Области видимости - это такие текстовые фрагменты вашей программы, в которых локальные неймспейсы, которые вы создаете
# доступны напрямую.

def b():
    x=31
    def a():
        print(x)
    a()

print(b())
# 31
# None

# Область видимости функции б будет тело этой функции: назовем b scope

    # x=31
    # def a():
    #     print(x)
    # a()

# a scope - это тело этой функции

# print(x)

# У нас есть еще и глобальная область видимости. global scope

# def b():
#     x=31
#     def a():
#         print(x)
#     a()

# print(b())

# Прежде всего важно понимать, что области видимости статичны. Они зависят лишь кода, который вы напишите. И ни как не зависят от самого исполнения.
# Однако в процессе исполнения нашего кода областям видимости соответствуют локальные неймспейсы, которые мы создаем при вызове функций.
# Допустим, глобальному скойпу соответствует глобальный неймспейс. Области видимости функции б будет соответствовать локальный неймспейс функции б и т.д.

# Таким образом, мы можем покрыть весь наш код областями видимости одни из которых будут включать в себя другие и такое покрытие не будет зависеть от самого исполнения.

# Посмотрев на наш код мы можем понять, что у нас есть global scope - он включает в себя b scope, который включает в себя a scope.

# Однако, когда мы находимся в процессе исполнения кода, например, какой-нибудь функции х() мы всегда можем разбить scope-ы на 4 категории:

# 1 - локальный scope, который по сути и есть локальный неймспейс функции х()
# 2 - закрывающие scope-ы или те скоупы, в который мы находимся до глобального скоупа
# 3 - глобальный скоуп
# 4 - скоуп, который соответствует builtins

# Таким образом, для поиска переменной внутри какой-либо функции верно правило LEGB

# L - local, E - enclosing, G - global, B - builtins

# Важно понимать, что поиск какого-либо имени объекта, который ему соответствует мы будем в неймспейсах, которые будут соответствовать данным скоупам
# а не самих скоупах, потому что скоупы - это всего лишь какой-то кусок кода.

# Таким образом, в нашем коде, когда интерпретатор захочет исполнить строку принт(х) внутри вызова функции а, которая находится внутри функции б
# то произойдет следующее: сначала он возьмет имя принт (посмотрит в а скоупе его нет, в б скоупе его тоже нет, в глобал его нет, найдет его в builtins)
# затем он проделает тоже самое для икса (в локальном скоупе не найдет, но найдет в скоупе функции б)

# Вы можете заметить, что порядок обхода неймспейсов для поиска имени принт и имени икс в данном примере абсолютно эквивалентен обходу локальных неймспейсов функций
# которые лежат на стеке в данный момент, однако очень важно понимать, что это не всегда так

# Давайте рассмотрим следующий пример

def a():
    print(x)
def b():
    x = 31
    a()
print(b())



# внутри нашего скоупа глобал определено 2 функции: а и б, поэтому их скоупы находятся внутри нашего скоупа глобал.
# Тогда когда мы вызовем вызов функции б() и внутри тела функции б интерпретатор найдет строчку с вызовом функции а() и мы начнем
# исполнять функцию а. То мы дойдем до конструкции принт(х)

# Мы начнем искать имя принт(): сначала мы посмотрим в внутри неймспейса, который ассоциирован со скоупом функции а, т.е. с локальным неймспейсом функции а
# там не найдем. Затем в глобальный неймспейс там тоже его нет. И затем в неймспейс builtins, где найдем функцию принт()

# и мы пойдем по такому же пути, когда будем искать имя х.

# внутри функции а у нас не объявлено имя х, поэтому мы пойдем в глобал, там так же не объявлено никакое имя икс, поэтому мы пойдем в builtins
# в builtins мы имя икс не найдем, поэтому вызов функции b() вернем нам "NameError: name 'x' is not defined". 
# Несмотря на то, что внутри функции б() мы объявили переменную х.

# Самым правильным решением таких ситуаций будет объявление аргументов у функций

# Таким образом, в языке Python поиск переменный осуществляется по пространству имен, которые связаны с соответствующим им областям видимости.
# Области видимости мы перебираем в следующем порядке:
# Сначала мы перебираем локальную область видимости, которой соответствует локальный неймспейс
# затем енклозинг или закрывающий скоуп, которому так же соответствуют неймспейсы тех функций, которые мы создали в момент вызова
# затем мы перебираем глобальный неймспейс
# затем неймспейс builtins