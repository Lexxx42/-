# Слукавил, когда говорил, что когда интерпретатор встречает какое-то число он будет создавать новый объект
# Это не всегда верно для неизменяемых типов

# Рассмотрим числа и значения логического типа
# 1, 2, 3
# True
# False

# для значений логического типа в памяти хранится всего 2 объекта: True, False

# Каждый раз, когда интерпретатор встречает в коде True он не будет создавать для этого объект
# он будет переиспользовать уже созданный
# То же самое для False

# То же равно и для чисел
a = 1
b = 1
c = 1

# нет ничего страшного, если все эти переменные будут ссылаться на один объект 1
# потому что до тех пор, пока мы не можем изменить объект 1, все что должно быть 1 так и останется 1

# что мы тогда можем гарантировать, когда напишем

x = 24

# все что мы можем гарантировать в случае для неизменяемых типов, что если объект 24 в памяти
# еще не было, то тогда он будет создан, а если он уже был, то можно переиспользовать старый

# В свою очередь для изменяемых типов данных в языке python все куда более честно

# Рассмотрим на примере списков
# для списков гарантируется, что когда интерпретатор встретит в коде список
# он создаст для него новый объект
x = []
y = []
print(id(x))  # 2851524034624
print(id(y))  # 2851525583872

# Когда интерпретатор встретит строку x = [] он создаст для него пустой список, как объект в памяти
# х будет ссылаться на этот объект
# тоже самое для у
# Таким образом верно, что когда интерпретатор встречает список он всегда будет создавать новый объект
# Это верно для всех изменяемых типов языка python
