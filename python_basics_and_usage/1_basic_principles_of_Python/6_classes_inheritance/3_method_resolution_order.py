# Порядок разрешения методов, последовательность наследования

# Остается открытым достаточно интересный вопрос: если у нас экземпляр х класса А
# и мы пытаемся вызвать у х каких-нибудь метод, который не является атрибутом нашего экземпляра х,
# и который не является атрибутом нашего класса А.
# Тогда, если для А мы использовали множественное наследование, в каком же из классов,
# от которых мы наследуемся, мы должны найти ту функцию, которая будет связана с методом
# нашего объекта х.

# Когда мы не использовали множественное наследование все было достаточно просто:#
# Пример:

class MyList(list):
    def even_length(self):
        return len(self) % 2 == 0


x = MyList()
print(x)  # []
x.extend([1, 2, 3, 4, 5])
print(x)
print(x.even_length())  # False
x.append(2)
print(x.even_length())  # True

print(isinstance(x, list))  # True


# Mylist -> list -> object
# в первую очередь, когда мы ищем метод extend(), проверяется является ли метод атрибутом объекта х
# затем проверяется наличие в классе MyList, после в классе list и заканчивается проверкой в классе object
# если нигде до этого не было найдено.
# Если нигде не найдем, то завершаем исполнение с ошибкой.

# Стоит заметить, что мы воспользовались методами листа сильно раньше.

# Прежде всего, когда мы запустили для нашего экземпляра х конструктор MyList()
# что происходит в интерпретаторе? Каждый раз, когда интерпретатор видит конструктор,
# он пытается внутри этого класса найти метод __init__(self),
# чтобы проинициализировать экземпляр, который создается.

# т.к. метод init не находится в классе MyList, потому что мы его там не определили, то
# он находится выше, в классе list.

# Поэтому конструктор, который мы запускаем на самом деле, когда мы создаем экземпляр класса
# MyList - это на самом деле конструктор list-а.

# Когда мы вызываем метод print() какого-нибудь экземпляра, то интерпретатор пытается внутри этого
# экземпляра метод __repr__(self). repr - это сокращенно representation - представление.

# Этот метод должен возвращать строковое представление объекта, который мы будем выводить в консоль
# при принте, например. Когда мы не находим этот метод в MyList-е, мы идем искать в list, находим его там
# поэтому представление нашего экземпляра х выглядит так же, как у листа.

# Теперь мы убедились в том, что методы вызываются гораздо чаще, чем мы их вызываем сами.
# Поэтому очень важно понимать порядок, в котором мы перебираем классы, когда ищем функцию,
# чтобы связать ее с методом.

# Особенно сильно это важно, в том случае, когда мы используем множественное наследование.

# Вернемся к примеру.
# Пускай наш класс MyList наследуется не только от листа, а еще от какого-нибудь класса.
# тогда становится не тривиальным вопрос, если мы вызываем какой-то метод
# нашего экземпляра х: x.method_name(), в каком же порядке мы должны перебрать классы,
# когда ищем функцию, чтобы сопоставить ее нашему связанному методу.

# Для того чтобы решать подобные конфликты в языке python есть порядок разрешения методов.

# Порядок разрешения методов определяется в момент создания класса.
# В языке python мы можем вызвать его с помощью метода mro, который есть у любого класса

# Вернемся к нашему старому примеру
class D: pass


class E: pass


class B(D, E): pass


class C: pass


class A(B, C): pass


print('***')

print(
    A.mro())  # [<class '__main__.A'>, <class '__main__.B'>,
# <class '__main__.D'>, <class '__main__.E'>,
#  <class '__main__.C'>, <class 'object'>]
# mro - method resolution order
# Мы увидели список классов. Это тот порядок, в котором мы бы их перебирали,
# когда мы бы искали метод. т.е. если бы у нас был бы экземпляр класса А х: х = А()
# мы бы пытались исполнить метод х.method() и это не является атрибутом самого экземпляра
# мы бы поискали в классе А, а затем в классе В, затем в классе -> D, -> Е, -> С, -> object

# и как только перебирая классы в подобном порядке мы бы нашли функцию method() внутри этого класса
# мы бы останавливались и связывали бы эту функцию с нашим методом.

# Что же нам гарантирует порядок разрешения методов?

# Прежде всего, каждый предок нашего класса там будет в единственном числе, мы можем увидеть,
# что здесь всего лишь 6 элементов - и это ровно все шесть классов, которые у нас
# участвуют в наследовании.

# Так же мы можем гарантировать, что если мы наследовали какой-нибудь класс А от класса В,
# то в нашем порядке разрешения методов сначала будет А, а затем В.
# т.е. в нашем случае D наследуется от object-а, при этом object находится после D
# не обязательно, что он следует сразу после D, главное чтобы он был в порядке разрешения
# после D.

# Если мы использовали множественное наследование, то мы можем гарантировать, что родительские классы
# будут следовать в том же порядке, в котором они указаны в скобках слева направо.
# т.е. в нашем случае для класса А мы знаем, что А наследуется от В и С.
# поэтому у нас сначала следует класс А, затем класс В, затем С.
# Здесь так же не обязательно, что класс С следует сразу за классом В,
# а класс В следовал сразу за классом А.

# Конечно вы будете редко встречаться с такими сложными схемами, однако, общее понимание
# того, что при множественном наследовании мы перебираем родителей в том же порядке,
# в котором мы их объявляем крайне важно.

# Давайте рассмотрим множественное наследование на примере MyList-а.
# Как бы мы могли написать MyList используя множественное наследование.
print('***')


# Мы бы сначала написала класс примесь
class EvenLengthMixin:
    def even_length(self):
        return len(self) % 2 == 0


# В этом классе у нас был бы всего лишь один метод, который проверяет длину на четность
# Примесь мы его назвали потому, что будем примешивать его функциональность к нашему основному классу.
# В нашем случае - это list.


class MyList1(list, EvenLengthMixin):
    pass


# В нашем случае, наш класс MyList1 наследуется от класса list, а затем наследуется от EvenLengthMixin.

print(MyList1.mro())
# [<class '__main__.MyList1'>, <class 'list'>,
# <class '__main__.EvenLengthMixin'>, <class 'object'>]
# Несложно убедиться в том, как же выглядит наш порядок разрешения методов.
# сначала будет MyList1, но в нем мы ничего не найдем.
# затем будет наш основной класс list, в котором мы будем находить почти все,
# а все, что не найдем мы поищем в нашей примеси,
# а затем пойдем искать в object-е.

x = MyList1([1, 2, 3])
print(x.even_length())  # False
x.append(12)
print(x.even_length())  # True

# Таким образом, конструктор мы найдем в нашем классе list, потому что ОН ТАМ ЕСТЬ :)

# а затем мы будем вызывать метод even.length() и т.к. в list-е его нет,
# мы пойдем и поищем его в примеси.
# Убедимся, что пока что наш лист нечетной длины.

# Мы запусти метод append()
# который мы так же сможем найти в list-е, и можем убедиться в том, что теперь
# мы имеем список четной длины.

# Самое замечательное, в том что мы используем такую примесь,
# это то, что в качестве класса, которому мы добавляем функциональность
# подойдет любой класс у которого есть длина.
# Например мы могли вместо списка так же использовать словарь или строку.

print('**')


class MyDict(dict, EvenLengthMixin):
    pass


y = MyDict()
y["key"] = "value"
y["another_key"] = "another_value"
print(y.even_length())  # True

# А что же случится, если мы попробуем определить в нашем классе метод, с таким же именем как и в
# одном из родительских классов
# Да в общем-то ничего страшного, т.е. мы конечно можем использовать метод с подобным именем
# давайте рассмотрим пример

print('***')


class EvenLengthMixin1:
    def even_length(self):
        return len(self) % 2 == 0


# Стоит помнить, что метод pop() так же определен внутри list-а и он возвращает последний элемент этого списка
# и список сокращается на этот самый элемент.
class MyList2(list, EvenLengthMixin):
    def pop(self):
        v = super(MyList2, self).pop()
        print("Last value is", v)  # Last value is 17
        return v


# Теперь, когда мы вызываем метод pop() у экземпляра нашего класса MyList2, мы будем вызывать
# функцию из класса MyList2.


ml = MyList2([1, 2, 3, 17])
z = ml.pop()
print(z)  # 17
print(ml)  # [1, 2, 3]
# Однако иногда возникает необходимость вызвать этот метод так, как будто он не определен внутри нашего класса.

# А определен в одном из родительских классов.
# для этого есть функция super().

# Функция super() принимает два аргумента: 1й аргумент - это класс родителя, которого мы хотим проверить,
# 2й - это объект с которым мы хотим проассоциировать метод.

# Таким образом, когда мы напишем конструкцию: super(MyList2, self).pop()
# мы пойдем искать метод pop() в родителях класса MyList2 в том же порядке,
# в котором они перечисленны в порядке разрешения методов, исключая сам MyList2.
# А затем функцию, которую найдем мы проассоциируем с объектом self.

# Получается, что такая запись абсолютно эквивалентна, если мы бы вызвали list.pop(self)
# функцию pop() и класса list и передали туда self явно.

# И в таком случае, вся наша функция pop() из класса MyList2 ведет себя в точности так, как ведет себя
# функция pop() в классе list, однако она вводит дополнительную информацию на экран о том,
# какое было получено последнее значение в списке.

# Таким образом, механизм наследования и множественного наследования, в том числе функция super(),
# нужны нам ровно тогда, когда функциональности какого-то класса нам немножко, но нехватает.
# и мы хотели бы ее дополнить, но при этом сделать так, чтобы в основном наш объекты
# вели себя так же, как объекты этого класса.

# Именно для этого мы используем наследование.
