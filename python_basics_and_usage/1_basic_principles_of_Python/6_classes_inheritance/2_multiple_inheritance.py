# Множественное наследование

# Язык python поддерживает множественное наследование
# Это значит, что когда мы создаем класс, мы можем выбрать несколько классов,
# от которых будет наследоваться наш класс.

# Проще всего визуализировать всю информацию о наследовании с помощью графов,
# где вершины - это классы, а из класса А есть ребро в класс Б
# если класс А наследуется от класса Б


#   D     E
#      B       C
#          A

class D: pass


class E: pass


class B(D, E): pass


class C: pass


class A(B, C): pass


# Данный граф хорошо изображает то, что написано в коде, однако он не отображает
# одной важной детали языка python

# Если мы явно не наследуем класс из какого-либо другого класса,
# то класс наследуется от класса Object

# Поэтому все три класса, в нашем примере, которые ни от чего не наследовались
# на самом деле наследуются от класса Object

# object: D, E, C наследуются от него

#   D     E
#      B       C
#          A

# Здесь следует немного прояснить определения:
# те классы, от которых мы наследуемся проще всего называть родителями или родительскими классами
# А родители родителей и т.д. представляют собой предков нашего класса

# т.е. в нашем рисунке, на самом деле, все классы, кроме класса А,
# являются предками класса А

# И при этом никакой класс, допустим, не является предком класса object
# И при этом класс D не является предком класса С

# Однако, формально говоря на языке теории графов, мы говорим, что вершина B - является предком
# вершины A, если из А есть путь в вершину B.

# Например, D является предком вершин класса А просто потому, что существует путь
# из А в В, из В в D
# Однако D не является предком вершины С, потому что такого пути не существует из С в D

# Используя такое определение, кто является предком кого не сложно убедится, что
# класс object является предком любого класса в языке python

# Однако для того, чтобы понять для двух конкретных классов, кто является предком кого
# или кто является наследником кого-то проще всего использовать стандартные средства языка python
# а точнее функцию issubclass()

# функция принимает 2 аргумента. Она проверяет, что первый аргумент является наследником второго.

print(issubclass(A, A))  # True
print(issubclass(C, D))  # False
print(issubclass(A, D))  # True
print(issubclass(C, object))  # True
print(issubclass(object, C))  # False

# Когда говорят, что А является предком В, то В является наследником А.

# Первое, на что следует обратить внимание, что если мы запустим функцию issubclass(А, А)
# передав в нее сам класс в качестве обоих аргументов, она возвращает значение Тру
# т.е. мы считаем, что любой класс является наследником самого себя

# Однако куда более интересно, чаще всего знать, ведет ли себя объект
# как экземпляр какого-нибудь класса

# для этого в языке python есть функция isinstance()
# функция isinstance() также принимает

print("***")

x = A()
print(isinstance(x, A))  # True
print(isinstance(x, B))  # True
print(isinstance(x, object))  # True
print(isinstance(x, str))  # False

# Давайте создадим экземпляр класса А - х
# передадим его первым аргументом в функцию, а вторым аргументом передадим наш класс А

# Функция isinstance() отвечает на один простой вопрос: является ли тип первого аргумента
print('***')
print(type(x))  # <class '__main__.A'>


# наследником второго аргумента F

# Но куда более важно, что же мы имеем в виду, когда мы запускаем эту функцию
# Когда мы вызываем функцию isinstance() с каким-то объектом и с каким-то типом.
# Мы на самом деле спрашиваем у интерпретатора можем ли мы использовать данный объект в качестве
# объекта данного типа

# Давайте рассмотрим пример из предыдущего шага

class MyList(list):
    def even_length(self):
        return len(self) % 2 == 0


print("***")
x = MyList()
print(x)  # []
x.extend([1, 2, 3, 4, 5])
print(x)
print(x.even_length())  # False
x.append(2)
print(x.even_length())  # True

print(isinstance(x, list))  # True
# Мы спрашиваем у интерпретатора: можем ли мы использовать х в качестве листа
# Таким образом, то как мы можем использовать экземпляр класса зависит ни лишь от класса,
# но и от классов, от которых он наследуется.

# Таким образом, если наш класс А наследуется от класса В и С,
# то экземпляр класса А сможет вести себя, как экземпляр класса В,
# так и экземпляр класса С.

# Для этого и нужно, прежде всего, множественное наследование.
