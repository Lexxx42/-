# Наследование классов

# Так же язык Python поддерживает наследование классов.

# Наследование классов нужно тогда, когда мы хотим, чтобы наш объект вел себя почти точно так же как объект другого типа
# за меленьким или за немаленьким исключением.

# Допустим мы бы хотели, чтобы наш объект вел себя точно так же как листы, но при этом у него был дополнительный метод, который определяет
# является ли число элементов в числе четным или нечетным.
# и при этом мы бы не хотели писать класс листа с самого нуля.

# для этого есть наследование классов.

# Начнем мы конечно с синтаксиса, как мы определяем класс, который наследуется от других классов.
# class DerivedClassName(Base1, Base2, Base3)
# <statement-1>
# .
# .
# .
# <statement-N>
# после имени класса, в скобках мы указываем те классы, от которых идет наследование
# При этом, когда интерпретатор исполняет определение класса, он запоминает, что за нашим DCN (DerivedClassName)
# что он наследовался от 3х классов: Base1, Base2, Base3

# В дальнейшем, интерпретатор будет использовать эту информацию, чтобы правильно находить атрибуты.

# Теперь давайте попробуем расширить функционал стандартного списка языка python

class MyList(list):
    def even_length(self):
        return len(self) % 2 == 0


x = MyList()
print(x) # []
x.extend([1, 2, 3, 4, 5])
print(x)
print(x.even_length()) # False
x.append(6)
print(x.even_length()) # True

# Можно заметить, что представление экземпляра MyList х - совпадает с представлением пустого листа
# Теперь давайте попробуем вызвать метод листа extend() 
# несмотря на то, что мы не описывали этот метод внутри нашего класса MyList мы можем его использовать.
# Вся фишка заключается в том, что теперь, когда мы не находим имя внутри неймспейса экземпляра
# и не находим имя в неймспейсе нашего класса, мы смотрим и проверяем неймспейсы классов,
# от которых мы наследовались и ищем там.

# таким образом, не найдя имя в неймспейсе внутри икса, и не найдя имя в неймспейсе MyList
# мы находим имя extend  в неймсейсе List. И запускаем метод extend() для листа.

# После этого мы можем вызвать функцию, которую мы уже описали внутри MyList.

# Поиск атрибутом будет происходить также.

# Этот метод в действительности покажет, что наш лист нечетной длины, мы можем так же дописать в него
# используя метод листа. И он становится четной длины.

# Таким образом, наследование позволило нам всего в три строки написать класс, который в точности так же ведет себя как класс.
# Но при этом имеет один дополнительный метод, который проверяет является ли данный метод является ли
# данный лист четной длины.
