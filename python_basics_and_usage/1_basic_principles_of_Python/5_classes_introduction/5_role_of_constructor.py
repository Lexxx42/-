# Конструктор нужен прежде всего для того, чтобы создавать новые объекты нашего класса
# и в языке Python существует возможность определить поведение конструктора.

# Это быть нужно для того, чтобы мы могли определить некоторые значения атрибутов
# уже созданных экземпляров по умолчанию.

# Для того чтобы определить поведение конструктора необходимо объявить функцию init внутри нашего класса

# Давайте вернемся к нашему классу Counter и попробуем написать у него такой конструкт
# который бы для каждого созданного экземпляра устанавливал атрибут Count = 0

# для этого мы должны внутри класса Counter написать функцию __init__, которая начинается с двух
# нижних подчеркиваний

class Counter:
    def __init__(self):
        self.count = 0


# Эта функция init принимает один аргумент self и ничего не возвращает.

# Counter # class object
x = Counter()
print(x.count)  # 0
x.count += 1


# Давайте разберемся как же работает конструктор.
# В общем случае функция init принимает на самом деле не один аргумент, а больше.
# Она может принимать дополнительные аргументы, что самое главное:
# первый аргумент, который она принимает это уже какой-то экземпляр нашего класса.

# Т.е. вообще процесс создания такой:
# Сначала создается пустой объект класса
# Пустой в том смысле, что у него нет ни одного атрибута.
# Неймспейс, который ассоциирован с этим объектом является изначально пустым.

# Уже этот объект передается в функцию __init__ в качестве self
# внутри self мы можем присвоить ему какие-то атрибуты, например как мы это делали
# self.count = 0 - в нашей функции и присваиваем self count=0

# Функция init не должна мне возвращать какое-либо значение, т.е.
# из разного рода функций результат должен быть None
# Это связано с тем, что идеологически функция init всего лишь
# устанавливает атрибуты для нашего объекта self
# т.е. self уже пустой экземпляр нашего класса и его же изменяет и устанавливает в него атрибуты
# именно он является результатом работы конструктора.

# Т.е. х будет ссылатьсяна тот же измененный self, который мы передали внутрь конструктора.
# После того, как мы создали экземпляр класса и наш конструктор отработал
# несложно убедиться в том, что атрибут был действительно установлен
# Теперь x.count = 0

# Установленный в конструкторе атрибуты ведут себя так же, как и другие атрибуты.
# Можем менять их прямо здесь же.
# Мы можем прямо сейчас добавить в x.count единичку

# Важно напомнить, что не обязательно функция init принимала всего один аргумент self
# она так же может принимать и другие аргументы и это часто может быть полезно.
# Допустим, мы хотели бы, чтобы нас счетчик каунтер начинал свое счисление
# не с только с нуля, но и с какого-нибудь произвольного значения, допустим с 10.

class Counter:
    def __init__(self, start=0):
        self.count = start


x1 = Counter(10)
x = Counter()
print(x.count, x1.count)
x.count += 1

# Когда мы запускаем наш конструктор с аргументами
# все аргументы, которые следуют в скобках начинают инициализировать переменные
# после слова self

# т.е. первый аргумент self в нашем случае, он всегда инициализируется объектом
# который является объектом экземпляром пустым.
# а все следующие аргументы начинают инициализироваться теми аргументами,
# которые мы передали внутрь конструктора
