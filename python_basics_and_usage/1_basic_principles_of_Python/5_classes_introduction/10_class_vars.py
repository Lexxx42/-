# Описанный механизм поиска атрибутов на самом деле работает не только для методов
# и если атрибут, который мы не нашли в экземпляре и нашли в классе, и не является функцией
# то мы просто можем его использовать.

# Давайте посмотрим следующий пример

# Если мы заходим написать какой-нибудь класс, который в нашем представлении хранил песни нашего мп3-плеера
# что бы мы от него хотели?
# прежде всего мы бы от него хотели, чтобы он хранил названия исполнителей, название песен и какие-нибудь теги
# чтобы мы потом могли сортировать наш плей листы по каким-нибудь тегам.

# Что же у нас на примере?

# Плохой пример

class Song:
    tags = []

    def __init__(self, artist, song):
        self.artist = artist
        self.song = song

    def add_tags(self, *args):
        self.tags.extend(args)


song1 = Song("Shakey Graves", "Roll the Bones")
song1.add_tags("Americana", "Country")

song2 = Song("Neuromonah Feofan", "Holodno v lesu")
song2.add_tags("Russian", "D'n'b")
print(song2.tags)  # ['Americana', 'Country', 'Russian', "D'n'b"]

# Этот пример примечателен парой вещей:

# Во-первых, мы определяем функцией конструктора, которая принимает не только self, но и другие аргументы

# А во-вторых, мы сейчас рассмотрим механизм того, как же происходит поиск атрибутов

# сначала мы создадим сонг1, добавим в него теги.
# создадим сонг2, добавим теги в него.

# Наш метод self.add.tags пытается добавить теги в атрибут self.tags
# однако важно понимать, что в конструкторе и нигде в коде мы явно не определяем tags у каждого из экземпляров
# поэтому, т.к. интерпретатор не может найти tags у экземпляра, он находит tags в классе

# Раз он нашел его в классе, он должен добавить туда теги. Т.е. каждый раз, когда мы вызываем self.tags.extend(args)
# tags не найден в экземпляре, то он использует явно Song.tags
# Таким образом, наши теги , когда мы каждый раз вызываем метод self.tags.extend(args) добавится в один и тот же объект

# Если мы попробуем посмотреть этот атрибут у экземпляра сонг2 мы увидим, что несмотря на то, что мы пытались добавить
# только теги, которые связаны со второй песней все они добавились в один и тот же объект.
# Более того мы бы могли проверить, что сонг2 явно is Song.tags

print(song2.tags is Song.tags)  # True

# Этот пример является плохим по двум причинам:

# Прежде всего мы имели в виду, что tags должны быть атрибутом именно конкретного экземпляра, потому что теги мы
# ассоциируем с песней, а не с классом.

# Во-вторых, метод add_tags на самом деле не менял не какого объекта. Идеологически неправильно использовать метод
# потому что он на самом деле менял класс, а не объект.

# Этого всего можно было бы легко избежать, если бы мы явно определяли атрибут tags внутри конструктора
print('******')


class Song:
    tags = []

    def __init__(self, artist, song):
        self.artist = artist
        self.song = song
        self.tags = []

    def add_tags(self, *args):
        self.tags.extend(args)


song1 = Song("Shakey Graves", "Roll the Bones")
song1.add_tags("Americana", "Country")

song2 = Song("Neuromonah Feofan", "Holodno v lesu")
song2.add_tags("Russian", "D'n'b")
print(song2.tags)  # ['Russian', "D'n'b"]

print(song2.tags is Song.tags)  # False
